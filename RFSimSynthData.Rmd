---
title: "KNN simulation synthetic data"
author: "Thomas Devilee"
date: "9-5-2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r}
library(foreach)
library(tidyverse)
library(doParallel)
registerDoParallel(cores = 4)
source("sampling_funcs.R")
set.seed(1979418)
```


```{r}
randomsplit <- function(regs, indx, spltb_reg, nodesize, leafsize = 1){
  unq_indx <- names(spltb_reg)
  splt_indx <- rep(NA, nrow(regs))
  
  for (i in 1:length(unq_indx)){
    sub_indx <- indx == unq_indx[i]
    sub_regs <- regs[sub_indx, ]
    n_sub <- sum(as.numeric(sub_indx))
    if(n_sub < 2*leafsize | all(!spltb_reg[[unq_indx[i]]]) | n_sub < nodesize) next
    splt <- TRUE
    while(splt){
      splt_indx[sub_indx] <- 1
      rcol <- sample(seq(1,ncol(regs)), size = 1)
      if (!rcol %in% which(spltb_reg[[unq_indx[i]]])) next
      rrow <- sample(1:nrow(sub_regs), size = 1)
      ineq_vec <- parse(text = paste(sub_regs[rrow, rcol], sample(c("<", "<=", ">=", ">"), size = 1), sub_regs[, rcol]))
      cond_indx <- sapply(ineq_vec, eval)
      splt_indx[sub_indx][cond_indx] <- 2
      if (var(splt_indx[sub_indx]) != 0) splt <- FALSE
    }
  }
  return(as.character(splt_indx))
}

updatesplit <- function(regs, indx, spltb_reg, nodesize, leafsize){
  out <- indx
  updt_indx <- randomsplit(regs = regs, indx = indx, spltb_reg = spltb_reg, nodesize = nodesize, leafsize = leafsize)
  log_indx <- !is.na(updt_indx)
  out[log_indx] <- paste0(indx[log_indx], updt_indx[log_indx])
  return(out)
}

regsplits <- function(regs, indx, leafsize){
  indx_names <- unique(indx)
  out <- vector(mode = "list", length = length(indx_names))
  names(out) <- indx_names
  
  for (i in 1:length(indx_names)){
    regs_sub <- regs[(indx == indx_names[i]), ]
    tmp <- vector(mode = "list", length = ncol(regs))
    
    for (j in 1:ncol(regs)){
      cumtable <- table(regs[, j])
      tmp[[j]] <- (sum(cumtable) - max(cumtable)) >= leafsize
    }
    
    out[[indx_names[i]]] <- drop(do.call(rbind, tmp))
    
  }
  return(out)
}

gensplits <- function(regs, maxdepth = NA, maxnodes = NA, nodesize = NA, leafsize = 1){
  if (is.na(maxnodes)) maxnodes <- nrow(regs)
  if (is.na(maxdepth)) maxdepth <- nrow(regs)
  if (is.na(nodesize)) nodesize <- 2
  indx <- rep("1", nrow(regs))
  out <- t(matrix(indx))
  out <- rbind(out, out)
  
  i <- 1
  spltb_reg <- regsplits(regs, out[i, ], leafsize = leafsize)
  psbl_split <- any(unlist(spltb_reg))
  while (max(nchar(out[i, ])) - 1 < maxdepth &
         length(unique(out[i, ])) < maxnodes &
         !all(table(out[i, ]) < 2*leafsize) &
         any(table(out[i, ] >= nodesize)) &
         psbl_split
         ){
    tmp <- updatesplit(regs = regs, indx = out[i, ], spltb_reg = spltb_reg, nodesize = nodesize, leafsize = leafsize)
    
    if(max(nchar(tmp)) - 1 <= maxdepth &
       length(unique(tmp)) <= maxnodes &
       all(table(tmp) >= leafsize)){
      
      out[i + 1, ] <- tmp
      i <- i + 1
      out <- rbind(out[1:i, ], out[i, ])
      spltb_reg <- regsplits(regs, out[i, ], leafsize = leafsize)
      psbl_split <- any(unlist(spltb_reg))
    }
  }
  return(out[i, ])
}

gentrees <- function(regs, n_tree, maxdepth = NA, maxnodes = NA, nodesize = NA, leafsize = 1){
  pckgs <- as.vector(lsf.str(.GlobalEnv))
  out <- foreach(j = 1:n_tree, .combine = "cbind", .export = pckgs) %dopar% {
    splts <- gensplits(regs = regs, maxdepth = maxdepth, maxnodes = maxnodes, nodesize = nodesize, leafsize = leafsize)
    sapply(splts, FUN = function(x) as.numeric(substr(x, nchar(x), nchar(x)) == 2))
  }
  rownames(out) <- NULL
  colnames(out) <- 1:n_tree
  return(out)
}

S <- function(X, y){
  num <- sum((t(y) %*% X)^2)
  denom <- t(y)  %*% y
  return(drop(num/denom))
}


randomRF <- function(regs, labs, n_tree, n_perms, maxdepth = NA, maxnodes = NA, nodesize = NA, leafsize = 1){
  y <- as.matrix(labs)
  pckgs <- as.vector(lsf.str(.GlobalEnv))
  X <- gentrees(regs = regs, n_tree = n_tree, maxdepth = maxdepth, maxnodes = maxnodes, nodesize = nodesize, leafsize = leafsize)
  stat <- S(X, y)
  
  permed_stat <- foreach(j = 1:n_perms, .combine = "c", .export = pckgs) %dopar% {
    yp <- y[sample(nrow(y)), ]
    S(X, yp)
  }
  return(1 - mean(stat > permed_stat))
}

EmpericalPower <- function(data){
  out <- apply(data, 2, function(x) mean(x < 0.05))
  return(out)
}
```

```{r}
StabExp <- function(n_tree, data, n_reps = 100, n_perms = 1000, leafsize = 5, maxdepth = NA, maxnodes = NA, nodesize = NA){
  labs <- data[, "y"] ### extract labels
  regs <- data[, !names(data) %in% "y"] ### extract predictors
  out <- vector(mode = "list", length = length(n_tree))
  for (i in 1:length(n_tree)){
    out[[i]] <- replicate(n_reps, expr = 
                             randomRF(regs = regs, labs = labs, n_tree = n_tree[i], n_perms = n_perms, leafsize = leafsize,
                                      maxdepth = maxdepth, maxnodes = maxnodes, nodesize = nodesize)
    )
  }
  return(out)
}
```

```{r}
is.int <- function(x) x%%1 == 0

create_folds <- function(n_folds, labs, balanced = TRUE, force = FALSE){
  if(balanced){
    if (any(order(as.numeric(labs[["y"]])) != seq(1, nrow(labs)))) stop("Data (labels) is not sorted") ### checks if the above requirments are met
    n1 <- nrow(labs) - sum(as.numeric(labs[["y"]]))
    n2 <- sum(as.numeric(labs[["y"]]))
    reps1 <- n1/n_folds
    reps2 <- n2/n_folds
    if ((!is.int(reps1) | !is.int(reps2)) & !force) stop("Cannot balance folds")
    folds1 <- rep(seq(1, n_folds), ceiling(reps1))[1:n1] ### create n fold indexes for group 1
    folds2 <- rep(seq(1, n_folds), ceiling(reps2))[1:n2] ### create n fold indexes for group 2
    folds <- c(sample(folds1), sample(folds2)) ### randomly assign indexes to each observation in a balanced fashion
  } else{
    folds <- sample(rep(seq(1, n_folds), nrow(labs)/n_folds)) ### randomly assign folds if balanced is false
  }
  return(folds)
}

SimExp <- function(data, n_reps, n_tree, indx = NA, n_perms = 1000, leafsize = 5, maxdepth = NA, maxnodes = NA, nodesize = NA){
  labs <- data[, "y"] ### extract labels
  regs <- data[, !names(data) %in% "y"] ### extract predictors
  res <- matrix(data = NA, nrow = n_reps, ncol = 1) ### initialize output matrix ### initialize output matrix
 ### assign names to the output matrix
  if(all(is.na(indx))){ ### if no weights specified
    indx <- create_folds(n_folds = n_reps, labs = labs) ### compute folds equal to the number of replications
  }
  
  for(i in 1:max(indx)){ ### for each folds
    sub_regs <- regs[indx == i,] ### select regressor subset
    sub_labs <- labs[indx == i,] ### select label subset
    res[i, 1] <- randomRF(regs = sub_regs, labs = sub_labs, n_tree = n_tree, n_perms = n_perms, leafsize = leafsize,
                                      maxdepth = maxdepth, maxnodes = maxnodes, nodesize = nodesize)
  }
  return(res)
}

pltmedquant <- function(data, nms = NA){
  if(is.na(nms)) nms <- 1:length(data)
  data_wide <- as.data.frame(do.call(rbind, data))
  colnames(data_wide) <- 1:ncol(data_wide)
  data_wide <- cbind(data_wide, n_tree = nms)
  data_long <- pivot_longer(data_wide, !last_col(), names_to = "reps", values_to = "p_value")
  out <- ggplot(data = data_long) + geom_pointrange(mapping = aes(x = n_tree, y = log10(p_value)),
                  stat = "summary",
                  fun.min = function(z) {quantile(z,0.025)},
                  fun.max = function(z) {quantile(z,0.975)},
                  fun = median) + ylab("log10 p-value") + xlab("Number of trees")
  return(out)
}
```

```{r}
n_tree <- c(50, 100, 250, 500, 1000)
LDA20 <- LDASamp(n_samples = 20, p = 2, effect = 25)
StabLDA20 <- StabExp(n_tree = n_tree, data = LDA20, n_reps = 100, leafsize = 5)
```

```{r}
LDA40 <- LDASamp(n_samples = 40, p = 2, effect = 25)
StabLDA40 <- StabExp(n_tree = n_tree, data = LDA40, n_reps = 100, leafsize = 8)
```

```{r}
LDA40 <- LDASamp(n_samples = 80, p = 2, effect = 25)
StabLDA80 <- StabExp(n_tree = n_tree, data = LDA80, n_reps = 10, leafsize = 16)
```

```{r}
CS20 <- CheckerSamp(n = 20, n_clusts = 3)
StabCS40 <- StabExp(n_tree = n_tree, data = CS20, n_reps = 100, leafsize = 60)
```

```{r}
CS40 <- CheckerSamp(n = 40, n_clusts = 3)
StabCS40 <- StabExp(n_tree = n_tree, data = CS40, n_reps = 100, leafsize = 125)
```

```{r}
LDASim <- function(sampsize, n_reps, effect, p, n_perms = 1000, n_tree = 250, leafsize = 1, maxdepth = NA, maxnodes = NA, nodesize = NA){
  indx_args <- c(length(p) > 1, length(effect) > 1, length(sampsize) > 1, length(n_tree) > 1, length(leafsize) > 1, length(maxdepth) > 1, length(maxnodes) > 1, length(nodesize) > 1)
  if(sum(as.numeric(indx_args)) > 1) stop("Only one parameter can have multiple values") ### only allow for one parameter to take on multiple values
  var_name <- c("p", "effect", "sampsize", "n_tree", "leafsize", "maxdepth", "maxnodes", "nodesize")[indx_args]
  params <- cbind(p, effect, sampsize, n_tree, leafsize, maxdepth, maxnodes, nodesize) ### parameter space
  out <- vector(mode = "list", length = nrow(params))
  for (i in 1:nrow(params)){
    data <- as_tibble(LDASamp(n_samples = params[i, "sampsize"] * n_reps, p = params[i, "p"], effect = params[i, "effect"]))
    tmp <- SimExp(n_reps = n_reps, data = data, indx = NA, n_tree = params[[i, "n_tree"]], n_perms = n_perms,
                  leafsize = params[[i, "leafsize"]], maxdepth = params[[i, "maxdepth"]],
                  maxnodes = params[[i, "maxnodes"]], nodesize = params[[i, "nodesize"]])
    out[[i]] <- EmpericalPower(tmp)
  }
  out <- do.call(rbind, out)
  if(sum(as.numeric(indx_args)) > 0){
    out <- data.frame(out, params[, var_name])
    colnames(out)[ncol(out)] <- var_name
    out <- pivot_longer(out, !last_col(), names_to = "method", values_to = "RF")
    out <- ggplot(data = out, aes(x = .data[[var_name]], y = RF, colour = method)) + geom_line(linetype = "dashed") + geom_point()
  }
  return(out)
}
```

```{r}
set.seed(1979418)
LDAs_depth <- LDASim(sampsize = 40, n_reps = 100, effect = 25, p = 2, maxdepth  = c(1, 2, 5, 10, 20, 40))
```


```{r}
CheckerSim <- function(n_reps, n, n_clusts, n_perms = 1000, n_tree = 250, leafsize = 1, maxdepth = NA, maxnodes = NA, nodesize = NA){
  indx_args <- c(length(n) > 1, length(n_clusts) > 1, length(n_tree) > 1, length(leafsize) > 1, length(maxdepth) > 1, length(maxnodes) > 1, length(nodesize) > 1)
  if(sum(as.numeric(indx_args)) > 1) stop("Only one parameter can have multiple values") ### only allow for one parameter to take on multiple values
  var_name <- c("n", "n_clusts", "n_tree", "leafsize", "maxdepth", "maxnodes", "nodesize")[indx_args]
  params <- cbind(n, n_clusts, n_tree, leafsize, maxdepth, maxnodes, nodesize) ### parameter space
  out <- vector(mode = "list", length = nrow(params))
  for (i in 1:nrow(params)){
    sampsize <- params[[i, "n_clusts"]]^2 * params[[i, "n"]]
    indx <- as.vector(sapply(1:n_reps, function(x, sampsize) rep(x, sampsize), sampsize = sampsize))
    data <- lapply(1:n_reps, FUN = function(x, n, n_clusts) CheckerSamp(n = n, n_clusts = n_clusts),
                   n = params[[i, "n"]], n_clusts = params[[i, "n_clusts"]])
    data <- as_tibble(do.call(rbind, data))
    tmp <- SimExp(n_reps = n_reps, data = data, indx = indx, n_tree = params[[i, "n_tree"]], n_perms = n_perms,
                  leafsize = params[[i, "leafsize"]], maxdepth = params[[i, "maxdepth"]],
                  maxnodes = params[[i, "maxnodes"]], nodesize = params[[i, "nodesize"]])

    out[[i]] <- EmpericalPower(tmp)
  }
  out <- do.call(rbind, out)
  if(sum(as.numeric(indx_args)) > 0){
    out <- data.frame(out, params[, var_name])
    colnames(out)[ncol(out)] <- var_name
    out <- pivot_longer(out, !last_col(), names_to = "method", values_to = "RF")
    out <- ggplot(data = out, aes(x = .data[[var_name]], y = RF, colour = method)) + geom_line(linetype = "dashed") + geom_point()
  }
  return(out)
}
```

```{r}
set.seed(1979418)
CS_depth <- CheckerSim(n = 20, n_clusts = 3, n_reps = 100, maxdepth = c(1, 2, 5, 10, 20, 40, 80, 180))
```

