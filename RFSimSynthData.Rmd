---
title: "RF simulation synthetic data"
author: "Thomas Devilee"
date: "9-5-2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r}
library(foreach)
library(tidyverse)
library(doParallel)
library(randomForest)
library(globaltest)
library(ggpubr)
registerDoParallel(cores = 4)

load("wsRFSynthData.RData")
source("corefuncs_rftests.R")
source("sampling_funcs.R")
source("aux_funcs.R")

wd <- "C:/Users/" ### set some directory to write all images to
```

### Randomforest code

### Stability experiment

```{r}
### function to perform the stability experiment
StabExp <- function(n_tree, data, n_reps = 100, n_perms = 1000, leafsize = 5, maxdepth = NA, maxnodes = NA, nodesize = NA){
  pckgs <- as.vector(lsf.str(.GlobalEnv)) ### required for parallel computing
  labs <- data[, "y", drop = FALSE] ### extract labels
  regs <- data[, !names(data) %in% "y"] ### extract predictors
  y <- matrix(residuals(lm(y ~ 1, data = labs)), nrow = nrow(labs)) ### orthogonalize with respect to an intercept
  
  out <- 
    foreach(i = 1:n_reps, .combine = "cbind", .packages = "foreach", .export = pckgs) %dopar% { ### parallel loop for the replications
      y_perm <- sapply(1:(n_perms - 1), function(x, y) y[sample(nrow(y)), ,drop = FALSE], y = y) ### permutations of y
      foreach (j = 1:length(n_tree), .combine = "c", .export = pckgs) %do% { ### sequential loop for the number of trees
        randomRF(regs = regs, y = y, y_perm = y_perm, n_tree = n_tree[j], leafsize = leafsize, maxdepth = maxdepth,
                 maxnodes = maxnodes, nodesize = nodesize) ### grows trees and compute p-value
      }
    }
  out <- data.frame(t(out), row.names = NULL) ### coerce results into a data frame (= rows represent number of trees)
  colnames(out) <- n_tree ### set col names to the number of trees
  return(out)
}
```

```{r}
n_tree <- c(50, 100, 250, 500, 1000, 2500, 5000, 10000, 25000)
set.seed(1979418)
LDAdata <- LDASamp(n_samples = 20, p = 2, effect = 2.5)
StabLDA <- StabExp(n_tree = n_tree, data = dat, n_reps = 100, leafsize = 3)
EmpericalPower(StabLDA)
```

```{r}
set.seed(123)
CSdata <- CheckerSamp(n = 3, n_clusts = 3)
StabCS <- StabExp(n_tree = c(n_tree, 50000, 100000), data = CSdata, n_reps = 100, leafsize = 2)
EmpericalPower(StabCS)
```

```{r}
### function to plot results from the stability and power experiments
powerplot <- function(..., x_names = NA, xlab = NA, sampsize = NA, alpha = 0.05){
  data <- list(...) ### collect all stability experiments
  if(all(is.na(x_names))) x_names <- 1:length(data) ### set default names for the number of trees when not specified
  if(all(is.na(sampsize))) sampsize <- NULL ### set default for the sample size when not specified
  data_long <- vector(mode = "list", length = length(data)) ### initialize
  for (i in 1:length(data)){ ### for each stability experiment
    tmp <- apply(data[[i]], 2,  function(x, alpha) mean(x < alpha), alpha = alpha) ### compute power over the columns (= number of trees)
    data_long[[i]] <- cbind(i, unlist(tmp), x_names) ### display the power results in a long format
    return(tmp)
  }
  data_long <- do.call(rbind.data.frame, data_long) ### concatenate all power results (row wise) in one matrix 
  colnames(data_long) <- c("exp", "power", "var") ### assign names to each of the columns
  out <- ggplot(data = data_long, aes(x = var, y = power, colour = factor(exp))) + geom_line(linetype = "dashed") + geom_point() + 
    ylim(c(0, 1)) + xlab(xlab) + ylab("Power") + scale_color_discrete(name = "Sample size", labels = sampsize) ### plot the results
  return(out)
}
```

```{r}
### function to plot results from the stability and power experiments
powerplot <- function(data, x_names = NA, xlab = NA, alpha = 0.05){
  if(all(is.na(x_names))) x_names <- 1:length(data) ### set default names for the number of trees when not specified
  tmp <- apply(data, 2,  function(x, alpha) mean(x < alpha), alpha = alpha) ### compute power over the columns (= number of trees)
  data_long <- as.data.frame(cbind(tmp, x_names)) ### display the power results in a long format
  colnames(data_long) <- c("power", "var") ### assign names to each of the columns
  out <- ggplot(data = data_long, aes(x = var, y = power)) + geom_line(linetype = "dashed") + geom_point() + 
    ylim(c(0, 1)) + xlab(xlab) + ylab("Power") + theme_minimal() + theme(plot.title = element_text(face = "bold")) ### plot the results
  return(out)
}
```

```{r}
plot_StabLDA <- powerplot(StabLDA, x_names = n_tree, xlab = "Number of trees")
```

```{r}
plot_StabCS <- powerplot(StabCS, x_names = c(n_tree, 50000), xlab = "Number of trees")
```

```{r}
pdf(paste0(wd,"RF_stab_combined.pdf"), onefile = FALSE)
ggarrange(plot_StabLDA + ggtitle("A"), plot_StabCS + ggtitle("B"), nrow = 1, ncol = 2, common.legend = FALSE)
dev.off()
```


### Tree depth experiment

```{r}
PowerExp <- function(mthd = "LDA", n_reps = 100, n_perms = 1000, n_tree = 250, leafsize = 1, maxdepth = NA, maxnodes = NA, nodesize = NA, ...){
  indx_args <- c(length(n_tree) > 1, length(leafsize) > 1, length(maxdepth) > 1, length(maxnodes) > 1, length(nodesize) > 1) ### check whether only one varied is being varied
  if(sum(as.numeric(indx_args)) > 1) stop("Only one parameter can have multiple values") ### only allow for one parameter to take on multiple values
  var_name <- c("n_tree", "leafsize", "maxdepth", "maxnodes", "nodesize")[indx_args] ### retrieve variable name that is being varied
  params <- cbind(n_tree, leafsize, maxdepth, maxnodes, nodesize) ### parameter space
  pckgs <- as.vector(lsf.str(.GlobalEnv)) ### required for parallel computing
  samp_ops <- list(...) ### collect all sampling options for LDA and CS in a list
  if(mthd == "LDA"){ ### for the LDA method
    data <- lapply(1:n_reps, FUN = function(x, sampsize, p, effect) LDASamp(n_samples = sampsize, p = p,
                   effect = effect), sampsize = samp_ops[["sampsize"]], p = samp_ops[["p"]], effect = samp_ops[["effect"]]) ### LDA sampling n_reps times according to the specified parameters
  } else if(mthd == "CS"){ ### for the CS method
     data <- lapply(1:n_reps, FUN = function(x, n_obs_clust, n_clusts) CheckerSamp(n = n_obs_clust, n_clusts = n_clusts),
                   n_obs_clust = samp_ops[["n_obs_clust"]], n_clusts = samp_ops[["n_clusts"]]) ### CS sampling n_reps times according to the specified parameters
  } else {stop("No sampling method specified")} ### check
  out <- 
    foreach(i = 1:n_reps, .combine = "rbind", .packages = "foreach", .export = pckgs) %dopar% {
      ### parallel loop for the replications
      data_sub <- data[[i]] ### subset the data
      labs <- data_sub[, "y", drop = FALSE] ### extract labels
      regs <- data_sub[, !names(data_sub) %in% "y"] ### extract predictors
      y <- matrix(residuals(lm(y ~ 1, data = labs)), nrow = nrow(labs)) ### orthogonalize with respect to the intercept
      y_perm <- sapply(1:(n_perms - 1), function(x, y) y[sample(nrow(y)), ,drop = FALSE], y = y) ### generate permutations of y
      foreach (j = 1:nrow(params), .combine = "c", .export = pckgs) %do% { ### sequential loop for elements from the varied parameter
        randomRF(regs = regs, y = y, y_perm = y_perm, params[[j, "n_tree"]], leafsize = params[[j, "leafsize"]],
                 maxdepth = params[[j, "maxdepth"]], maxnodes = params[[j, "maxnodes"]], nodesize = params[[j, "nodesize"]]) ### compute p-value
      }
    }
  out <- data.frame(out, row.names = NULL) ### coerce results into a data frame (= rows represent the elements of the varied paramater)
  colnames(out) <- eval(parse(text = var_name)) ### set col names to the name of the varied paramater
  return(out)
}
```


```{r}
set.seed(1979418)
LDAs_depth <- PowerExp(mthd = "LDA", sampsize = 20, effect = 5, p = 2, n_reps = 100, maxdepth  = c(seq(1, 10), 15, 10, 20))
```

```{r}
plot_LDAs_depth <- powerplot(LDAs_depth, x_names = c(seq(1, 10), 15, 10, 20), xlab = "Maximum tree depth")
```

```{r}
set.seed(1979418)
CS_depth <- PowerExp(mthd = "CS", n_obs_clust = 15, n_clusts = 3, n_reps = 100, maxdepth = c(seq(1, 10), 15, 25, 50, 80, 135))
```

```{r}
plot_CS_depth <- powerplot(CS_depth, x_names = c(seq(1, 10), 15, 25, 50, 80, 135), xlab = "Maximum tree depth")
```

```{r}
pdf(paste0(wd,"RF_depth_combined.pdf"), onefile = FALSE)
ggarrange(plot_LDAs_depth + ggtitle("A") + scale_x_continuous(breaks = seq(-1, 20, by = 2)), 
          plot_CS_depth + ggtitle("B") + scale_x_continuous(breaks = c(1, seq(15, 135, by = 15))), nrow = 1, ncol = 2, common.legend = FALSE)
dev.off()
```

### Simulation experiment

```{r}
### function to run all tests given some data
SimExp <- function(data, n_reps, indx = NA, n_perms = 1000, ...){
  pckgs <- as.vector(lsf.str(.GlobalEnv)) ### required for parallel computation
  labs <- data[, "y", drop = FALSE] ### extract labels
  regs <- data[, !names(data) %in% "y"] ### extract predictors
  if(all(is.na(indx))){ ### if no index specified
    indx <- create_folds(n_folds = n_reps, labs = labs, ...) ### compute folds equal to the number of replications
  }
  res <- matrix(data = NA, nrow = n_reps, ncol = 6) ### initialize output matrix
  colnames(res) <- c("linear.gt", "nestedcv.ridge", "fixedcv.rf", "fixed.rf_gt", "pval.rf_gt", "overall.Sgt") ### assign names to the output matrix
  
  for(i in 1:max(indx)){ ### for each folds
    sub_regs <- regs[indx == i,] ### select regressor subset
    sub_labs <- labs[indx == i, , drop = FALSE] ### select label subset
    folds_ridge <- create_folds(n_folds = 5, labs = sub_labs, ...) ### create folds for functions that require cross validation
    folds_rf <- create_folds(n_folds = 4, labs = sub_labs, ...)
    res[i, 1] <- linear.gt(regs = sub_regs, labs = sub_labs) ### compute p-value of the linear global test
    ridge_stat <- nestedcv.ridge(folds = folds_ridge, regs = sub_regs, labs = sub_labs) ### compute test statistic for the nested ridge
    rf_stat <- fixedcv.rf(folds = folds_rf, regs = sub_regs, labs = sub_labs) ### compute test statistic for the nested knn
    res[i, 4] <- fixed.rf_gt(regs = sub_regs, labs = sub_labs, n_perms = n_perms)
    res[i, 5] <- pval.rf_gt(regs = sub_regs, labs = sub_labs, n_perms = n_perms, ...)
    res[i, 6] <- overall.Sgt(regs = sub_regs, labs = sub_labs, n_perms = n_perms)
    
    perm_mat <- foreach(j = 1:(n_perms-1), .combine = "cbind", .export = pckgs) %do% { ### for n_perms replications
      perm_indx <- sample(nrow(sub_labs)) ### permutation index
      perm_regs <- sub_regs[perm_indx, ] ### permute regressors
      perm_folds_ridge <- create_folds(n_folds = 5, labs = sub_labs, ...) ### compute folds
      perm_folds_rf <- create_folds(n_folds = 4, labs = sub_labs, ...) ### compute folds
      perm_ridge <- nestedcv.ridge(folds = perm_folds_ridge, regs = perm_regs, labs = sub_labs) ### compute (permuted) test statistic for the nested ridge
      perm_rf <- fixedcv.rf(folds = perm_folds_rf, regs = perm_regs, labs = sub_labs) ### compute (permuted) test statistic for the nested knn
      matrix(c(perm_ridge, perm_rf), nrow = 2) ### return permuted test statistics for both tests
    }
    res[i, 2] <- mean(ridge_stat*(1-1e-14) <= c(Inf, perm_mat[1, , drop = TRUE])) ### compute emperical p-value for nested ridge
    res[i, 3] <- mean(rf_stat*(1-1e-14) <= c(Inf, perm_mat[2, , drop = TRUE])) ### compute emperical p-value for nested knn
  }
  return(res)
}
```

```{r}
### function for the LDA experiments --> power as function of the effect size, dimensionality or sample size
LDASim <- function(sampsize, n_reps, effect, p, n_perms = 1000, ...){
  indx_args <- c(length(p) > 1, length(effect) > 1, length(sampsize) > 1) ### check whether only one varied is being varied
  if(sum(as.numeric(indx_args)) > 1) stop("Only one parameter can have multiple values") ### only allow for one parameter to take on multiple values
  var_name <- c("p", "effect", "sampsize")[indx_args] ### retrieve variable name that is being varied
  params <- cbind(p, effect, sampsize) ### parameter space
  out <- vector(mode = "list", length = nrow(params)) ### generate list element for each element of the varied parameter
  pckgs <- as.vector(lsf.str(.GlobalEnv)) ### required for parallel computing
  start <- Sys.time() ### start time
  for (i in 1:nrow(params)){ ### for each value of the varied parameter
    cat("Start element", i, "\n") ### print start iteration element
    res <- foreach (j = 1:n_reps, .combine = "rbind", .export = pckgs, .packages = c("doParallel", "randomForest", "globaltest")) %dopar% {
      ### parallel loop for the replications
      data <- LDASamp(n_samples = params[i, "sampsize"], p = params[i, "p"], effect = params[i, "effect"]) ### sample data according to some parameters
      SimExp(n_reps = 1, data = data, indx = NA, n_perms = n_perms, ...) ### perform all tests
    }
    out[[i]] <- EmpericalPower(res) ### compute power over all replications for some parameter
    end <- Sys.time() ### end time
    cat("Finished element", i, "\n") ### print end iteration element
    print(end-start) ### return time difference
    start <- end ### set end time to start time
  }
  out <- do.call(rbind, out) ### return power results as matrix
  return(out)
}
```

```{r}
full_labs <- c("Fixed","Fixed cross-validation RF", "Linear GT",
               "Nested cross-validation ridge regression", "Sampling overall", "P-value")
set.seed(1979418)
LDAS_p <- LDASim(sampsize = 40, n_reps = 100, effect = 5, p = c(2, 10, 25, 50, 100))
plot_LDAS_p <- exprplot(data = LDAS_p, method = full_labs, x_names = c(2, 10, 25, 50, 100), xlab = "Dimensionality")
```

```{r}
LDAS_effect <- LDASim(sampsize = 40, n_reps = 100, effect = c(5, 4, 3, 2, 1), p = 2)
plot_LDAS_effect <- exprplot(data = LDAS_effect, method = full_labs, x_names = c(5, 4, 3, 2, 1), xlab = "Effect size")
```

```{r}
### function for the checkerboard experiments --> power as function of the number of observations per tile or number of tiles
CheckerSim <- function(n_reps, n, n_clusts, n_perms = 1000, ...){
  indx_args <- c(length(n) > 1, length(n_clusts) > 1) ### check whether only one varied is being varied
  if(sum(as.numeric(indx_args)) > 1) stop("Only one parameter can have multiple values") ### only allow for one parameter to take on multiple values
  var_name <- c("n", "n_clusts", "n_tree")[indx_args] ### retrieve variable name that is being varied
  params <- cbind(n, n_clusts) ### parameter space
  out <- vector(mode = "list", length = nrow(params)) ### generate list element for each element of the varied parameter
  pckgs <- as.vector(lsf.str(.GlobalEnv)) ### required for parallel computing
  start <- Sys.time() ### start time
  for (i in 1:nrow(params)){ ### for each value of the varied parameter
    cat("Start element", i, "\n") ### print start iteration element
    res <- foreach (j = 1:n_reps, .combine = "rbind", .export = pckgs, .packages = c("doParallel", "randomForest", "globaltest")) %dopar% { ### parallel loop for the replications
      data <- CheckerSamp(n = params[[i, "n"]], n_clusts = params[[i, "n_clusts"]]) ### sample data according to some parameters
      SimExp(n_reps = 1, data = data, indx = NA, n_perms = n_perms, ...) ### perform all tests
    }
    out[[i]] <- EmpericalPower(res) ### compute power over all replications for some parameter
    end <- Sys.time() ### end time
    cat("Finished element", i, "\n") ### print end iteration element
    print(end-start) ### return time difference
    start <- end ### set end time to start time
  }
  out <- do.call(rbind, out) ### return power results as matrix
  return(out)
}
```

```{r}
CBS_nclusts <- CheckerSim(n_reps = 100, n = 3, n_clusts = c(3, 5), force = TRUE)
plot_CBS_nclusts <- exprplot(data = CBS_nclusts, method = full_labs, x_names = c(3, 5), xlab = "Board length") + scale_x_continuous(breaks = c(3, 4,5))
```

```{r}
set.seed(1979)
CBS_n <- CheckerSim(n_reps = 100, n = c(2, 5, 10), n_clusts = 3, force = TRUE)
plot_CBS_n <- exprplot(data = CBS_n, method = full_labs, x_names = c(2, 5, 10), xlab = "Observations per tile")
```

```{r}
pdf(paste0(wd,"RF_combined.pdf"), onefile = FALSE)
ggarrange(plot_LDAS_p + ggtitle("A"), plot_LDAS_effect + ggtitle("B"), 
          plot_CBS_n + ggtitle("C"), plot_CBS_nclusts + ggtitle("D"), nrow = 2, ncol = 2, common.legend = TRUE, legend = "bottom")
dev.off()
```

