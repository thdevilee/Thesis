---
title: "KNN simulation synthetic data"
author: "Thomas Devilee"
date: "06/04/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load data and packages
```{r}
library(foreach)
library(tidyverse)
library(parallel)
library(doParallel)
library(class)
library(globaltest)
library(glmnet)
library(MASS)
library(gridExtra)
library(ggpubr)
registerDoParallel(cores = 4)

load("wsKNNSynthData.RData")
source("corefuncs_knntests.R")
source("sampling_funcs.R")
source("aux_funcs.R")

wd <- "C:/Users/" ### set some directory to write all images to
```

```{r}
data_exp1 <- data.frame(X1 = c(-1, -1, 2, 2, 2), X2 = c(1, 0, 1, 0, -10))
plot_exp1 <- ggplot(data = data_exp1, aes(x = X1, y = X2)) + geom_point() + ylim(c(-10, 10)) + xlim(-10, 10) +
  theme_minimal() + theme(plot.title = element_text(face = "bold"))
```

```{r}
data_exp2 <- data.frame(X1 = c(-1,0, 1), X2 = c(0, 0 , 1))
plot_exp2 <- ggplot(data = data_exp2, aes(x = X1, y = X2)) + geom_point() + ylim(c(-1.5, 1.5)) + xlim(-1.5, 1.5) +
  theme_minimal() + theme(plot.title = element_text(face = "bold"))
```

```{r}
pdf(paste0(wd,"KNN_exp_combined.pdf"), onefile = FALSE)
ggarrange(plot_exp1 + ggtitle("A"), plot_exp2 + ggtitle("B"), nrow = 1, ncol = 2, common.legend = FALSE)
dev.off()
```

```{r}
set.seed(1979418)
data_exp3 <- CheckerSamp(n = 4, n_clusts = 3)
pdf(paste0(wd,"KNN_exp_checker.pdf"))
ggplot(data = data_exp3, aes(x = x1, y = x2, col = y)) + geom_point(show.legend = FALSE) + theme_minimal() +
  ylab("X2") + xlab("X1")
dev.off()
```


```{r}
pckgs <- as.vector(lsf.str())
  
### function to run all tests given some data
SimExp <- function(data, n_reps, pckgs, indx = NA, n_perms = 1000, ...){
  labs <- data[, "y"] ### extract labels
  regs <- data[, !names(data) %in% "y"] ### extract predictors
  if(all(is.na(indx))){ ### if no weights specified
    indx <- create_folds(n_folds = n_reps, labs = labs, ...) ### compute folds equal to the number of replications
  }
  res <- matrix(data = NA, nrow = n_reps, ncol = 8) ### initialize output matrix
  colnames(res) <- c("linear.gt", "nestedcv.ridge", "nestedcv.knn", "prop.knn_gt", "pval.knn_gt", "overall.gt", "invoverall.gt", "overordinall.gt") ### assign names to the output matrix
  
  for(i in 1:max(indx)){ ### for each folds
    sub_regs <- regs[indx == i,] ### select regressor subset
    sub_labs <- labs[indx == i,] ### select label subset
    dist_mat <- comp_dist(sub_regs) ### compute distance matrix
    ord_mat <- knn_mat(dist_mat) ### compute ordering matrix
    folds <- create_folds(n_folds = 5, labs = sub_labs, ...) ### create folds for functions that require cross validation
    res[i, 1] <- linear.gt(regs = sub_regs, labs = sub_labs) ### compute p-value of the linear global test
    ridge_stat <- nestedcv.ridge(folds = folds, regs = sub_regs, labs = sub_labs) ### compute test statistic for the nested ridge
    knn_stat <- nestedcv.knn(folds = folds, regs = sub_regs, labs = sub_labs) ### compute test statistic for the nested knn
    res[i, 4] <- prop.knn_gt(labs = sub_labs, ord_mat = ord_mat) ### compute p-value for the global test on the partition matrix based on the label proportion
    res[i, 5] <- pval.knn_gt(regs = sub_regs, labs = sub_labs, ...) ### compute p-value for the global test based on the value of k which has the smallest p-value in the training set
    res[i, c(6, 7)] <- overall.gt(labs = sub_labs, ord_mat = ord_mat, n_perms = 1000, invweighted = TRUE) ### compute unweighted and inversely weighted overall gloval test
    res[i, 8] <- overallordinal.gt(labs = sub_labs, ord_mat = ord_mat) ### compute unweighted and inversely weighted overall gloval test
    
    perm_mat <- foreach(j = 1:n_perms, .combine = "cbind", .export = pckgs) %do% { ### for n_perms replications
      perm_indx <- sample(nrow(sub_labs)) ### permutation index
      perm_regs <- sub_regs[perm_indx, ] ### permute regressors
      perm_folds <- create_folds(n_folds = 5, labs = sub_labs, ...) ### compute folds
      perm_ridge <- nestedcv.ridge(folds = perm_folds, regs = perm_regs, labs = sub_labs) ### compute (permuted) test statistic for the nested ridge
      perm_knn <- nestedcv.knn(folds = perm_folds, regs = perm_regs, labs = sub_labs) ### compute (permuted) test statistic for the nested knn
      matrix(c(perm_ridge, perm_knn), nrow = 2) ### return permuted test statistics for both tests
    }
    res[i, 2] <- mean(ridge_stat*(1-1e-14) <= c(Inf, perm_mat[1, , drop = TRUE])) ### compute emperical p-value for nested ridge
    res[i, 3] <- mean(knn_stat*(1-1e-14) <= c(Inf, perm_mat[2, , drop = TRUE])) ### compute emperical p-value for nested knn
  }
  return(res)
}
```

```{r}
### function for the checkerboard experiments --> power as function of the number of observations per tile or number of tiles
CheckerSim <- function(n_reps, n, n_clusts, n_perms = 1000, ...){
  indx_args <- c(length(n) > 1, length(n_clusts) > 1) ### check whether only one varied is being varied
  if(sum(as.numeric(indx_args)) > 1) stop("Only one parameter can have multiple values") ### only allow for one parameter to take on multiple values
  var_name <- c("n", "n_clusts")[indx_args] ### retrieve variable name that is being varied
  params <- cbind(n, n_clusts) ### parameter space
  out <- vector(mode = "list", length = nrow(params)) ### generate list element for each element of the varied parameter
  pckgs <- as.vector(lsf.str(.GlobalEnv)) ### required for parallel computing
  start <- Sys.time() ### start time
  for (i in 1:nrow(params)){ ### for each value of the varied parameter
    cat("Start element", i, "\n") ### print start iteration element
    res <- foreach (j = 1:n_reps, .combine = "rbind", .export = pckgs, .packages = c("doParallel", "globaltest", "tidyverse")) %dopar% { ### parallel loop for the replications
      data <- as_tibble(CheckerSamp(n = params[[i, "n"]], n_clusts = params[[i, "n_clusts"]])) ### sample data according to some parameters
      SimExp(n_reps = 1, data = data, indx = NA, n_perms = n_perms, pckgs = pckgs, ...) ### perform all tests
    }
    out[[i]] <- EmpericalPower(res) ### compute power over all replications for some parameter
    end <- Sys.time() ### end time
    cat("Finished element", i, "\n") ### print end iteration element
    print(end-start) ### return time difference
    start <- end ### set end time to start time
  }
  out <- do.call(rbind, out) ### return power results as matrix
  return(out)
}
```

```{r}
full_labs <- c("Uniform overall", "Linear GT", "Nested cross-validation kNN",
               "Nested cross-validation ridge regression", "Overall", "Ranked distance", 
               "Proportion ", "P-value")
set.seed(19794)
CBS_nclusts <- CheckerSim(n_reps = 100, n = 3, n_clusts = c(3, 5), n_perms = 1000, force = TRUE)
plot_CBS_nclusts <- exprplot(data = CBS_nclusts, method = full_labs, x_names = c(3, 5), xlab = "Board length") + scale_x_continuous(breaks = c(3, 4,5))
```

```{r}
CBS_n <- CheckerSim(n_reps = 100, n = c(2, 5, 10), n_clusts = 3, n_perms = 1000, force = TRUE)
plot_CBS_n <- exprplot(data = CBS_n, method = full_labs, x_names = c(2, 5, 10), xlab = "Observations per tile")
```

```{r}
### function for the LDA experiments --> power as function of the effect size, dimensionality or sample size
LDASim <- function(sampsize, n_reps, effect, p, n_perms = 1000, ...){
  indx_args <- c(length(p) > 1, length(effect) > 1, length(sampsize) > 1) ### check whether only one varied is being varied
  if(sum(as.numeric(indx_args)) > 1) stop("Only one parameter can have multiple values") ### only allow for one parameter to take on multiple values
  var_name <- c("p", "effect", "sampsize")[indx_args] ### retrieve variable name that is being varied
  params <- cbind(p, effect, sampsize) ### parameter space
  out <- vector(mode = "list", length = nrow(params)) ### generate list element for each element of the varied parameter
  pckgs <- as.vector(lsf.str(.GlobalEnv)) ### required for parallel computing
  start <- Sys.time() ### start time
  for (i in 1:nrow(params)){ ### for each value of the varied parameter
    cat("Start element", i, "\n") ### print start iteration element
    res <- foreach (j = 1:n_reps, .combine = "rbind", .export = pckgs, .packages = c("doParallel", "globaltest", "tidyverse")) %dopar% { ### parallel loop for the replications
      data <- as_tibble(LDASamp(n_samples = params[i, "sampsize"], p = params[i, "p"], effect = params[i, "effect"])) ### sample data according to some parameters
      SimExp(n_reps = 1, data = data, indx = NA, n_perms = n_perms, pckgs = pckgs, ...) ### perform all tests
    }
    out[[i]] <- EmpericalPower(res) ### compute power over all replications for some parameter
    end <- Sys.time() ### end time
    cat("Finished element", i, "\n") ### print end iteration element
    print(end-start) ### return time difference
    start <- end ### set end time to start time
  }
  out <- do.call(rbind, out) ### return power results as matrix
  return(out)
}
```

```{r}
set.seed(1979418)
LDAS_p <- LDASim(sampsize = 40, n_reps = 100, effect = 5, p = c(2, 10, 25, 50, 100), n_perms = 1000)
plot_LDAS_p <- exprplot(data = LDAS_p, method = full_labs, x_names = c(2, 10, 25, 50, 100), xlab = "Dimensionality")
```

```{r}
set.seed(197941)
LDAS_effect <- LDASim(sampsize = 40, n_reps = 100, effect = c(5, 4, 3, 2, 1), p = 2, n_perms = 1000)
plot_LDAS_effect <- exprplot(data = LDAS_effect, method = full_labs, x_names = c(5, 4, 3, 2, 1), xlab = "Effect size")
```

```{r}
pdf(paste0(wd,"KNN_combined.pdf"), onefile = FALSE)
ggarrange(plot_LDAS_p + ggtitle("A"), plot_LDAS_effect + ggtitle("B"), 
          plot_CBS_n + ggtitle("C"), plot_CBS_nclusts + ggtitle("D"), nrow = 2, ncol = 2, common.legend = TRUE, legend = "bottom")
dev.off()
```


